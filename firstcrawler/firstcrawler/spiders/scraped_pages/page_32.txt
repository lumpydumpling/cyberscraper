URL: https://www.linux.com/audience/hacking-the-linux-kernel-in-ada-part-2/
Title: Hacking the Linux Kernel in Ada
Text Content: For this three part series, we implemented a ‘pedal to the metal’ GPIO driven, flashing of a LED, in the context of a Linux kernel module for the NVIDIA Jetson Nano development board (kernel-based v4.9.294, arm64) in my favorite programming language … Ada!You can find the whole project published at https://github.com/ohenley/adacore_jetson. It is known to build and run properly. All instructions to be up and running in 5 minutes are included in the accompanying front-facing README.md. Do not hesitate to fill a Github issue if you find any problem.Disclaimer: This text is meant to appeal to both Ada and non-Ada coders. Therefore I try to strike a balance between code story simplicity, didactic tractability, and features density. As I said to a colleague, this is the text I would have liked to cross before starting this experiment. (pecification file, Ada equivalent to C .h header file) is where we model a simple interface for our LED.For those new to Ada, many interesting things happen for a language operating at the metal.The top-level code story resides in . Immediately when the module is loaded by the kernel,  executes, called from our  entry point. It first imports the elaboration procedure  generated by GNATbind, runs it,  our LED object, and then setup/registers the delayed work queue.In the callback, instead of printing to the kernel message buffer, we call the  implementation of our LED object and re-register to the delayed work queue. It now flashes.If you search the web for images of “NVIDIA Jetson Development board GPIO header pinout” you will find such diagram.Right away, you figure there are about 5 data fields describing a single pinoutLooking at this diagram we find hints of the different mapping happening at the Tegra SoC, Linux, and physical pinout level. Each “interface” has its own addressing scheme. The Tegra SoC has logical naming and offers default and alternate functions for a given GPIO line. Linux maintains its own GPIO numbering of the lines so does the physical layout of the board.From where I stand I want to connect a LED circuit to a board pin and control it without fuss, by using any addressing scheme available. For this we created an array of variant records instantiation, modeling the pin characteristics for the whole header pinouts. Nothing cryptic or ambiguous, just precise and clear structured data.Because everything in this  data assembly is unique and unrelated it cannot be generalized further, it has to live somewhere, plainly. Let’s check how we model a single pin as . is a variant record, meaning, based on a , it will contain “variable” data. Notice how we range over the  values to describe the switch cases. This gives us the capability to model all pins configuration.When you consult the Technical Reference Manual (TRM) of the Nano board, you find that GPIO register controls are layed out following an arithmetic pattern. Using some hardware entry point constants and the specifics of a pin data held into , one can resolve any register needed.In this experiment, it is mainly used to request the kernel memory mapping of such GPIO register.Now, let’s model a common Pinmux register found in the TRM.I think the code speaks for itself.You can now directly address bitfield/s by name and not worry about any bitwise arithmetic mishap. Ok so now what about logically addressing a bitfield/s? You pack inside arrays. We do have an example in the modeling of the GPIO register.Now we can do.I had to give you a feel of what is to gain by modeling using Ada. To me, it is about semantic clarity, modeling affinity, and structural integrity. Ada offers flexibility through a structured approach to low-level details. Once set foot in Ada, domain modeling becomes easy because as you saw, you are given provisions to incisively specify things using strong user-defined types. The stringent compiler constraints your architecture to fall in place on every iteration. From experience, it is truly amazing how the GNAT toolchain helps you iterate quickly while keeping technical debt in check.Ada is not too complex, nor too verbose; those are mundane concerns.Ada demands you to demonstrate that your modeling makes sense for thousands of lines of code; it is code production under continuous streamlining.In the last entry, we will finally meet the kernel. If I kept your interest and you want to close the loop, move here. Cheers!I want to thank Quentin Ochem, Nicolas Setton, Fabien Chouteau, Jerome Lambourg, Michael Frank, Derek Schacht, Arnaud Charlet, Pat Bernardi, Leo Germond, and Artium Nihamkin for their different insights and feedback to nail this experiment.The author, Olivier Henley, is a UX Engineer at AdaCore. His role is exploring new markets through technical stories. Prior to joining AdaCore, Olivier was a consultant software engineer for Autodesk. Prior to that, Olivier worked on AAA game titles such as For Honor and Rainbow Six Siege in addition to many R&D gaming endeavors at Ubisoft Montreal. Olivier graduated from the Electrical Engineering program in Polytechnique Montreal. He is a co-author of patent US8884949B1, describing the invention of a novel temporal filter implicating NI technology. An Ada advocate, Olivier actively curates GitHub’s Awesome-Ada list.
Data: 5303 Bytes 
total data: 347860 Bytes 
Found keywords: ['switch', 'architecture', 'data', 'controls', 'Linux', 'kernel', 'file', 'configuration']