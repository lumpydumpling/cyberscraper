URL: https://www.linux.com/audience/hacking-the-linux-kernel-in-ada-part-3/
Title: Hacking the Linux Kernel in Ada
Text Content: For this three-part series, we implemented a ‘pedal to the metal’ GPIO driven, flashing of a LED, in the context of a Linux kernel module for the NVIDIA Jetson Nano development board (kernel-based v4.9.294, arm64) in my favorite programming language … Ada!You can find the whole project published at https://github.com/ohenley/adacore_jetson. It is known to build and run properly. All instructions to be up and running in 5 minutes are included in the accompanying front-facing README.md. Do not hesitate to fill a GitHub issue if you find any problem.Disclaimer: This text is meant to appeal to both Ada and non-Ada coders. Therefore I try to strike a balance between code story simplicity, didactic tractability, and features density. As I said to a colleague, this is the text I would have liked to cross before starting this experiment.Our code boundary to the Linux kernel C methods lies in . For an optional “adaptation” opportunity,  exists before breaking into the concrete C binding. Take  ( equivalent in kernel space) for example. In C, you would call . Ada strings are not null-terminated, they are an array of characters. To make sure the passed Ada string stays valid on the C side, you expose specification signatures  that make sense when programming from an Ada point of view and “adapt” in body implementation  before calling directly into the binding. Strictly speaking, our exposed Ada  would qualify as a “thick” binding even though the adaptation layer is minimal. This is in opposition to a “thin” binding which is really a one-to-one mapping on the C signature as implemented by .Binding to a wrapped C  or  is often convenient, potentially makes you inherit fixes, upgrades happening inside/under the macro implementation and are, depending on the context, potentially more portable.  used in  as found in Part 1 makes a perfect example. Our driver has a C home in . You create a C wrapping function calling the macro.You then bind to this wrapper on the Ada side and use it. Done.Sometimes a macro called on the C side creates stuff, in place, which you end up needing on the Ada side. You can probably always bind to this resource but I find it often impedes code story. Take  for example. From an outside point of view, it implicitly creates  in place.Using this macro, the only way I found to get a hold of  from Ada without crashing (returning  from a wrapper never worked) was to globally call  in main.c and then bind only to . Having to maintain this from C, making it magically appear in Ada felt “breadboard wiring” to me. In the code repository, you will find that we fully reconstructed this macro under the procedure of the same name .Most published Ada to C bindings implement full definition parity. This is an ideal situation in most cases but it also comes with complexity, may generate many 3rd party files, sometimes buried deep, out-of-sync definitions, etc. What can you do when complete bindings are missing or you just want to move lean and fast? If you are making a prototype, you want minimal dependencies, the binding part is peripheral eg. you may only need a quick native window API. You get the point.Depending on the context you do not always need the full type definitions to get going. Anytime you are strictly dealing with a handle pointer (not owning the memory), you can take a shortcut. Let’s bind to  to illustrate. Again, I follow and layout all C signatures found in the kernel sources leading to concrete stuff, where we can bind.Inspecting the C definitions we find that  and  are our available functions for binding. We note  uses a transient pointer of type . Because we do not touch or own a full  instance we can happily skip defining it in full (and any dependent leads eg. ).By declaring type Gpio_Desc_Acc is new System.Address; we create an equivalent to gpio_desc *. After all, a C pointer is a named system address. We now have everything we need to build our Ada version of gpio_get_value.In most production contexts we cannot recommend reconstructing unbindable kernel API calls in Ada. Wrapping the C macro or static inline is definitely easier, safer, portable and maintainable. The following goes full blown Ada for the sake of illustrating some interesting nuts and bolts and to show that it is always possible. Given the will power you can always reconstruct the targeted macro or static inline in Ada. Let’s come back to . If you take the time to expand its macro using GCC this is what you get.All arguments are straightforward to map except the ‘ed flags. Let’s search the kernel sources for those flags.Here are our design decisions for reconstructionBecause we do not use these flags elsewhere in our code base, the occasion is perfect to show that in Ada we can keep all this modeling local to our unique function using it.The core work of the happens in . Using , we retrieve the kernel mapped IO memory location for the  register physical address. We then write the content of our  to this IO memory location through .Let’s take the hard paths of full reconstruction to illustrate interesting stuff. We first implement . On the C side we findHere we are both lucky and unlucky.  is low hanging while  turns out to be a rabbit hole. I skip the intermediate expansion by reporting the final resultSearching for definitions in the kernel sources: (meaningful sampling only)The macro pattern  can be cleared right away. IIUC, it serves to handle calling both from assembly and C. When you are concerned by the C case, like we do, it boils down to , eg.  becomes . is in part ‘kernel configuration dependant’, defaulting to ‘yes’, so let’s simplify our job and bring it in,  which is the choice , for all cases. turns out to be  with  as input. Inspecting the kernel sources, there are four other values intended as input to .  behaves like a function so let implement it as such.Here I want to show another way to replicate C behavior, this time using bitwise operations. Something like  value  cannot be approached like we did before.  takes two bits and is somewhat a magic number. What we can do is improve on the representation. We are doing bit masks so why not express using binary numbers directly. It even makes sense graphically.So what is interesting here?Now we give a look at  and . Turns out those are, again, a cascade of static inline and macros ending up directly emitting GCC assembly directives (detailing only iowrite32).In Ada it becomesThis  implementation is not portable as we rebuilt the macro following the expansion tailored for arm64. A C wrapper would be less trouble while ensuring portability. Nevertheless, we felt this experiment was a good opportunity to show assembly directives in Ada.I hope you appreciated this moderately dense overview of Ada in the context of Linux kernel module developpement. I think we can agree that Ada is a really disciplined and powerful contender when it comes to system, pedal to the metal, programming. I thank you for your time and concern. Do not hesitate to reach out and, happy Ada coding!I want to thank Quentin Ochem, Nicolas Setton, Fabien Chouteau, Jerome Lambourg, Michael Frank, Derek Schacht, Arnaud Charlet, Pat Bernardi, Leo Germond, and Artium Nihamkin for their different insights and feedback to nail this experiment.The author, Olivier Henley, is a UX Engineer at AdaCore. His role is exploring new markets through technical stories. Prior to joining AdaCore, Olivier was a consultant software engineer for Autodesk. Prior to that, Olivier worked on AAA game titles such as For Honor and Rainbow Six Siege in addition to many R&D gaming endeavors at Ubisoft Montreal. Olivier graduated from the Electrical Engineering program in Polytechnique Montreal. He is a co-author of patent US8884949B1, describing the invention of a novel temporal filter implicating NI technology. An Ada advocate, Olivier actively curates GitHub’s Awesome-Ada list.
Data: 7961 Bytes 
total data: 314151 Bytes 
Found keywords: ['Linux', 'kernel', 'repository', 'file', 'configuration', 'system']