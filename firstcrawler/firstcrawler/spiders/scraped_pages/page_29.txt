URL: https://developer.android.com/codelabs/android-adv-workmanager
Title: Advanced WorkManager  |  Android Developers
Text Content: This codelab teaches advanced WorkManager concepts. It builds on the basic material covered in the  Background Work with WorkManager codelab.Other resources available to get familiar with WorkManager are:In this codelab you'll be working on Blur-O-Matic, an app that blurs photos and images and saves the result to a file. If you have already completed the  Background Work with WorkManager codelab, this is a similar sample app (the one difference is that this sample app allows you to select your own image from the photos gallery to blur).  Here you will add some features to the code:To do this codelab, you'll need the latest  Android Studio stable version.You should also be familiar with  ,    and  . If you're new to these classes, check out the  Android Lifecycle-aware components Codelab (specifically for ViewModel and LiveData) or  Room with a View Codelab (an introduction to Architecture Components).If you get stuck with this codelab at any point, or if you want to look at the final state of the code, you can   Or, if you prefer, you can clone the completed WorkManager codelab from GitHub:Click the following link to download the version of the code to follow along this codelab:Or if you prefer, you can clone the codelab from GitHub:This code sample uses View Binding to interact with views in place of .To learn more, check out the  View Binding documentation.Run the app. You should see the following screens. Make sure to grant the app permission to access your photos when prompted.You can select an image and get to the next screen, which has radio buttons where you can select how blurry you'd like your image to be. Pressing the  button will blur and save the image. During the blurring the app shows a  button to let you end the work.The starting code contains:You'll be making code changes in the following classes: , , , and . requires the gradle dependency below. These have been already included in the files:You should get the most current version of  from  the WorkManager release page and put a version for the latest stable release in, or use the one below:Make sure to click on  to sync your project with the changed Gradle files.In this step you will add a custom configuration to the app to modify WorkManager's logging level for debug builds.As described in the  Custom WorkManager configuration and initialization documentation, you have to disable the default initialization in your  file, by removing the node that is merged automatically from the WorkManager library by default.To remove this node, you can add a new provider node to your , as shown below:You'll also need to add the tools namespace to the manifest. The complete file with these changes will be:You can use an on-demand initialization by implementing WorkManager's   interface in your  class. The first time your application gets the WorkManager's instance using  , WorkManager initializes itself using the configuration returned by .With this change, WorkManager runs with logging set to .A better option is probably to set up WorkManager in this way only for debug builds of your app, using something like:The complete BlurApplication.kt then becomes:WorkManager is now configured in such a way that your debug builds log all the messages coming from the library.Running the app, you can see the logs in Android Studio's  tab:The full list of parameters is in WorkManager's reference guide for the  . Pay attention to two additional parameters:Modifying the  allows adding other parameters to your Worker's constructor. You can find more information about how to implement a custom WorkerFactory in this  Customizing WorkManager article. If you are using WorkManager as well as the  API in your app, it's a good idea to customize the  range to avoid that same  range being used by the two APIs.Sharing WorkManager's ProgressWorkManager v2.3 added the functionality to share progress information from your Worker to your app using the   (or   when used from a  ). This information can be observed through a WorkInfo, and is intended to be used to provide feedback in the UI to the user. The progress data is then cancelled when the worker reaches a final state (SUCCEEDED, FAILED, or CANCELLED). To know more about how to publish and listen for progress, read  Observing intermediate Worker progress.What you are going to do now is to add a progress bar in the UI so that, if the app is in foreground, the user can see how the blurring is proceeding. The end result will be like:To modify the ProgressBar in the layout you need to delete the  parameter, add the style  and set an initial value with . You also need to set the  orientation to :The other needed change is to be sure that the  does restart at the initial position. You can do this by updating the  function in the  file:There is already an observer in the  file that checks when your chain is completed. Add a new one that observes the progress posted by .First, add a couple of constants to track this at the end of the  file:The next step is to add this tag to the 's  in the  file so that you can retrieve its . From that , you can retrieve the worker's progress information:Add a new  to the  file that tracks this , and initialize the  in the  block:Step 3 - Observe the LiveData in the ActivityYou can now use this  in  to observe all the published progress. First register a new  observer at the end of the  method:Now you can check the  received in the observer to see if there is any progress information, and update the  accordingly:All the pieces needed to display the progress information are now in place. It's time to add the actual publishing of the progress information to .This example simply simulates some lengthy process in our  function so that it can publish progress information over a defined amount of time.The change here is to swap a single delay with 10 smaller ones, setting a new progress at each iteration:As the original delay was 3 seconds, it is probably a good idea to also reduce it by a factor of ten to 0.3 seconds:Running the application at this point it should show the ProgressBar populated with the messages coming from .The progress data shared with   or  , saves your progress data in WorkManager's Room database. This means that, if you publish a lot of data while your worker is running, it will require that space on the filesystem.For this reason, in this code sample, we called  only a few times and not for all the values in the loop.The progress data is only available while the Worker is in  state. As soon as the Worker reaches a final state, the progress information is purged from WorkManager's Room database.Testing is an important component of every application and, when introducing a library like WorkManager, it's important to provide the tools to easily test your code.With WorkManager, we also made some helpers available to easily test your Workers. To know more about how to create tests for your workers you can refer to  WorkManager documentation on testing.In this section of the codelab we're going to introduce some tests for our Worker classes showing some of the common use cases.First, we want to provide an easy way to setup our tests, to do this we can create a TestRule that setup WorkManager:Assuming that you already created the AndroidTest folder in your project, we need to add some dependencies to use in our tests:We can now start putting together the pieces with a TestRule that we can use in our tests:Because the application code works with image files on the device, you need a test image. In this example, the image has the path .As we will need this test image on the device (where the tests are going to be run) we can create a couple of helper functions to use in our tests:Once we have down this work, we can start writing our tests.First we test our , to check that it actually deletes our files. To do this,copy the test image on the device in the test, and then check if it's there after the  has been executed:You can now run this test from Android Studio from the Run menu, or using the green rectangle on the left side of your test class:You can also run your tests from the command line using the command  from the root folder of your project.You should see that your tests executes correctly.An alternative process is to write the test for a feature before implementing the feature itself ( TDD - Test Driven Development):In this way you are sure that the test actually tests your code.This is an especially good process to follow when fixing a bug in a feature:Next we can test our BlurWorker. This worker expects an input data with the URI of the image to process, so we can build a couple of tests:one that checks that the worker fails if there's no input URI, and one that actually processes the input image.If you run these tests, they should both succeed.Congratulations! You've finished the Blur-O-Matic app, and in the process you learned how to:Excellent "work"! To see the end state of the code and all the changes, check out:Or if you prefer, you can clone the WorkManager's codelab from GitHub:WorkManager supports a lot more than we could cover in this codelab. To learn more, head over to the  WorkManager documentation.Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 4.0 License, and code samples are licensed under the Apache 2.0 License. For details, see the Google Developers Site Policies. Java is a registered trademark of Oracle and/or its affiliates.
Data: 9501 Bytes 
total data: 331684 Bytes 
Found keywords: ['information', 'data', 'file', 'configuration', 'logs', 'testing', 'test']